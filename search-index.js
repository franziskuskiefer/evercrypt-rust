var searchIndex = JSON.parse('{\
"evercrypt":{"doc":"Evercrypt &amp; HACL Rust bindings","t":[0,0,0,0,0,0,0,0,0,0,0,6,3,13,13,13,6,13,13,4,13,13,13,13,13,13,6,4,6,6,13,11,11,11,11,11,11,11,11,5,11,5,11,5,11,11,11,5,11,5,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,5,11,11,5,11,5,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,13,3,4,13,4,13,13,13,13,13,13,13,13,13,13,5,5,11,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,5,5,11,11,11,11,11,5,5,5,5,5,5,5,5,5,5,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,4,13,13,13,4,13,13,13,11,11,11,11,11,11,5,5,11,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,4,13,6,6,6,11,11,5,5,11,11,11,11,5,5,11,11,11,11,5,5,5,4,13,13,13,13,11,11,11,11,11,11,11,11,5,5,11,11,5,11,11,11,11,11,13,4,13,13,13,13,13,6,6,6,3,13,11,11,11,11,11,11,5,5,5,5,11,11,11,11,11,11,11,11,5,11,5,11,11,11,11,11,11,11,11,5,5,11,11,5,5,5,5,13,4,13,13,13,13,4,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,5,11,11,11,11,11,11,11,5,11,11,4,13,6,6,11,11,5,5,11,11,11,11,5,11,11,11,11],"n":["aead","digest","ecdh","ed25519","hkdf","hmac","p256","prelude","rand_util","signature","x25519","Aad","Aead","Aes128Gcm","Aes256Gcm","Chacha20Poly1305","Ciphertext","Decrypting","Encrypting","Error","InvalidAlgorithm","InvalidCiphertext","InvalidInit","InvalidKeySize","InvalidNonce","InvalidTagSize","Key","Mode","Nonce","Tag","UnsupportedConfig","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","decrypt","decrypt","decrypt_combined","decrypt_combined","decrypt_in_place","decrypt_in_place","deserialize","drop","encrypt","encrypt","encrypt_combined","encrypt_combined","encrypt_in_place","encrypt_in_place","eq","eq","fmt","fmt","from","from","from","from","init","into","into","into","key_gen","key_gen","key_size","key_size","new","nonce_gen","nonce_gen","nonce_size","nonce_size","serialize","set_key","set_random_key","tag_size","tag_size","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","vzip","vzip","vzip","Blake2b","Blake2s","Digest","Error","InvalidStateFinished","Mode","ModeUnsupportedForStreaming","Sha1","Sha224","Sha256","Sha384","Sha3_224","Sha3_256","Sha3_384","Sha3_512","Sha512","blake2b","blake2s","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","deserialize","digest_size","eq","finish","fmt","fmt","from","from","from","from","get_digest_size","hash","into","into","into","new","serialize","sha1","sha224","sha256","sha384","sha3_224","sha3_256","sha3_384","sha3_512","sha512","shake128","shake256","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","update","vzip","vzip","vzip","Error","InvalidPoint","InvalidScalar","KeyGenError","Mode","P256","UnknownAlgorithm","X25519","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","derive","derive_base","deserialize","eq","eq","fmt","fmt","from","from","into","into","key_gen","serialize","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","vzip","vzip","Error","InvalidPoint","Point","Scalar","Signature","borrow","borrow_mut","eddsa_sign","eddsa_verify","eq","fmt","from","into","key_gen","sk2pk","try_from","try_into","type_id","vzip","expand","extract","hkdf","Mode","Sha1","Sha256","Sha384","Sha512","borrow","borrow_mut","clone","clone_into","deserialize","eq","fmt","from","get_tag_size","hmac","into","serialize","tag_size","to_owned","try_from","try_into","type_id","vzip","CompressedPoint","Error","InvalidConfig","InvalidPoint","InvalidScalar","InvalidSignature","KeyGenError","Nonce","PublicKey","Scalar","Signature","SigningFailed","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","dh","dh_base","ecdsa_sign","ecdsa_verify","eq","fmt","fmt","from","from","from_bytes","into","into","key_gen","new","random_nonce","raw","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","validate_pk","validate_sk","vzip","vzip","get_random_array","get_random_vec","random_array","random_vec","Ed25519","Error","HashAlgorithmMissing","InvalidPoint","InvalidSignature","KeyGenError","Mode","NonceMissing","P256","UnknownAlgorithm","borrow","borrow","borrow_mut","borrow_mut","clone","clone_into","deserialize","eq","eq","fmt","fmt","from","from","into","into","key_gen","serialize","sign","to_owned","try_from","try_from","try_into","try_into","type_id","type_id","verify","vzip","vzip","Error","InvalidPoint","Point","Scalar","borrow","borrow_mut","dh","dh_base","eq","fmt","from","into","key_gen","try_from","try_into","type_id","vzip"],"q":["evercrypt","","","","","","","","","","","evercrypt::aead","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","evercrypt::digest","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","evercrypt::ecdh","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","evercrypt::ed25519","","","","","","","","","","","","","","","","","","","evercrypt::hkdf","","","evercrypt::hmac","","","","","","","","","","","","","","","","","","","","","","","evercrypt::p256","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","evercrypt::rand_util","","","","evercrypt::signature","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","evercrypt::x25519","","","","","","","","","","","","","","","",""],"d":["Authenticated Encryption with Associated Data (AEAD)","Hashing","ECDH","Ed25519","HKDF","HMAC","","Prelude for Evercrypt. Include this to get access to all …","Utilities that provide randomness. Note that this …","","x25519","Associated data are byte arrays.","The Aead struct allows to re-use a key without having to …","","","","Ciphertexts are byte vectors.","","","","","","","","","","Aead keys are byte vectors.","The AEAD Mode.","Nonces are byte vectors.","Aead tags are byte vectors.","","","","","","","","","","Single-shot API for AEAD decryption.","Decrypt with the algorithm and key of this Aead. Returns …","Single-shot API for combined AEAD decryption.","Decrypt with the algorithm and key of this Aead. Returns …","Single-shot API for AEAD decryption in place.","Decrypt with the algorithm and key of this Aead.","","","Single-shot API for AEAD encryption.","Encrypt with the algorithm and key of this Aead. Returns …","Single-shot API for combined AEAD encryption.","Encrypt with the algorithm and key of this Aead. Returns …","Single-shot API for in place AEAD encryption.","Encrypt with the algorithm and key of this Aead. Returns …","","","","","","","","","Initialize a new Aead object without a key. Use <code>set_key</code> to …","","","","Generate a random key.","Generate a random key.","Get the key size of the <code>Mode</code> in bytes.","Get the key size of this Aead in bytes.","Create a new Aead cipher with the given Mode <code>alg</code> and key <code>k</code>.","Generate a nonce.","Generate a nonce.","Get the nonce size of the <code>Mode</code> in bytes.","Get the nonce size of this Aead in bytes.","","Set the key for this instance. This consumes the Aead and …","Generate a new random key for this instance. This consumes …","Get the tag size of the <code>Mode</code> in bytes.","Get the tag size of this Aead in bytes.","","","","","","","","","","","","","","","","The digest struct for stateful hashing.","","","The Digest Mode.","","","","","","","","","","","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","","","","","","","","","","Returns the output size of a digest.","","Finish the hash computation. Returns the digest or an <code>Error</code>…","","","","","","","","Create the digest for the given <code>data</code> and mode <code>alg</code>. The …","","","","Create a new digest for the given mode <code>alg</code>.","","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","Single-shot API with a fixed length output.","SHAKE 128","SHAKE 256","","","","","","","","","","","Update the hash state. Modifies <code>self</code> and doesn’t return …","","","","","","","","ECDH algorithm.","","","","","","","","","","Derive the ECDH shared secret. Returns <code>Ok(p * s)</code> on the …","Returns <code>Ok(base_point * s)</code> on the provided curve (<code>mode</code>) or …","","","","","","","","","","Generate a random <code>Scalar</code> on the given curve.","","","","","","","","","","","","","Points are 32 byte arrays.","Scalars are 32 byte arrays.","Signatures are 64 byte arrays.","","","Sign message <code>msg</code> with secret key <code>sk</code>. Returns a <code>Signature</code>.","Verify signature <code>signature</code> on message <code>msg</code> with public key …","","","","","Generate a random <code>Scalar</code>.","Compute the public <code>Point</code> for the given secret key <code>sk</code>.","","","","","HKDF expand using hash function <code>mode</code>, pre-key material <code>prk</code>…","HKDF extract using hash function <code>mode</code>, <code>salt</code>, and the input …","HKDF using hash function <code>mode</code>, <code>salt</code>, input key material <code>ikm</code>…","The HMAC mode defining the used hash function.","","","","","","","","","","","","","","Compute the HMAC value with the given <code>mode</code> and <code>key</code> on <code>data</code> …","","","Get the tag size for a given mode.","","","","","","","P256 errors","","","","","","Nonces are 32 byte arrays.","P256 public keys are 64-byte arrays containing the 32-byte …","Scalars are 32 byte arrays.","An ECDSA signature holding <code>r</code> and <code>s</code>.","","","","","","","","Return p * s","Return base * s","Sign <code>msg</code> with <code>sk</code> and <code>nonce</code> using <code>hash</code> with EcDSA on P256.","Verify EcDSA <code>signature</code> over P256 on <code>msg</code> with <code>pk</code> using <code>hash</code>.","","","","","","Generate a new signature from a byte array holding <code>r||s</code>.","","","Generate a new P256 scalar (private key).","Build a new signature from <code>r</code> and <code>s</code>.","Generate a random nonce for ECDSA.","Get the raw signature bytes. Returns a 64 byte array …","","","","","","","","","Validate a P256 secret key.","","","Generate a random array.","","Generate a random array. <em>PANICS</em> if randomness generation …","Generate a random byte vector of length <code>len</code>. <em>PANICS</em> if …","EdDSA on curve 25519","Signature errors.","","","","","Supported signature schemes.","","EcDSA on P256","","","","","","","","","","","","","","","","","Generate a new key pair for the given <code>mode</code>. The function …","","Sign a message <code>msg</code> with the secret key <code>sk</code> and the given …","","","","","","","","Verify a signature. Depending on the <code>Mode</code>, a <code>hash</code> mode has …","","","Curve 25519 errors","The computed or provided point is not on the curve.","Points are 32 byte arrays.","Scalars are 32 byte arrays.","","","Return p * s","Return base * s","","","","","Generate a random <code>Scalar</code>.","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,0,2,2,2,2,2,2,0,0,0,0,2,3,1,2,3,1,2,1,1,0,3,0,3,0,3,1,3,0,3,0,3,0,3,1,2,1,2,3,1,1,2,3,3,1,2,0,3,0,3,3,0,3,0,3,1,3,3,0,3,1,3,1,2,3,1,2,3,1,2,3,1,2,4,4,0,0,5,0,5,4,4,4,4,4,4,4,4,4,0,0,6,5,4,6,5,4,4,4,4,0,4,6,5,4,6,5,4,4,0,0,6,5,4,6,4,0,0,0,0,0,0,0,0,0,0,0,4,6,5,4,6,5,4,6,5,4,6,6,5,4,0,7,7,7,0,8,7,8,7,8,7,8,8,8,0,0,8,7,8,7,8,7,8,7,8,0,8,8,7,8,7,8,7,8,7,8,0,9,0,0,0,9,9,0,0,9,9,9,9,0,0,9,9,9,9,0,0,0,0,10,10,10,10,10,10,10,10,10,10,10,10,0,0,10,10,0,10,10,10,10,10,11,0,11,11,11,11,11,0,0,0,0,11,11,12,11,12,12,12,0,0,0,0,11,11,12,11,12,12,11,12,0,12,0,12,12,11,12,11,12,11,12,0,0,11,12,0,0,0,0,13,0,14,14,14,14,0,14,13,14,14,13,14,13,13,13,13,14,13,14,13,14,13,14,13,0,13,0,13,14,13,14,13,14,13,0,14,13,0,15,0,0,15,15,0,0,15,15,15,15,0,15,15,15,15],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[],["mode",4]],[[]],[[["mode",4],["aad",6]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["aad",6]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["mode",4],["aad",6]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["aad",6]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["mode",4],["aad",6]],["result",4,[["error",4]]]],[[["aad",6]],["result",4,[["error",4]]]],[[],["result",4]],[[]],[[["mode",4],["aad",6]],["result",4,[["error",4]]]],[[["aad",6]],["result",4,[["error",4]]]],[[["mode",4],["aad",6]],["result",4,[["ciphertext",6],["error",4]]]],[[["aad",6]],["result",4,[["ciphertext",6],["error",4]]]],[[["mode",4],["aad",6]],["result",4,[["tag",6],["error",4]]]],[[["aad",6]],["result",4,[["tag",6],["error",4]]]],[[["mode",4]],["bool",15]],[[["error",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[["u8",15]],["mode",4]],[[]],[[]],[[["mode",4]],["result",4,[["error",4]]]],[[]],[[]],[[]],[[["mode",4]],["key",6]],[[],["key",6]],[[["mode",4]],["usize",15]],[[],["usize",15]],[[["mode",4]],["result",4,[["error",4]]]],[[["mode",4]],["nonce",6]],[[],["nonce",6]],[[["mode",4]],["usize",15]],[[],["usize",15]],[[],["result",4]],[[],["result",4,[["error",4]]]],[[],["result",4,[["error",4]]]],[[["mode",4]],["usize",15]],[[],["usize",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[]],[[]],[[]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["mode",4]],[[]],[[],["result",4]],[[["mode",4]],["usize",15]],[[["mode",4]],["bool",15]],[[],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[["u32",15]],["mode",4]],[[]],[[["mode",4]],["usize",15]],[[["mode",4]],["vec",3,[["u8",15]]]],[[]],[[]],[[]],[[["mode",4]],["result",4,[["error",4]]]],[[],["result",4]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]],["vec",3,[["u8",15]]]],[[["usize",15]],["vec",3,[["u8",15]]]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["result",4,[["error",4]]]],[[]],[[]],[[]],null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],["mode",4]],[[]],[[["mode",4]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[["mode",4]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[],["result",4]],[[["error",4]],["bool",15]],[[["mode",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["mode",4]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[],["result",4]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[]],[[]],null,null,null,null,null,[[]],[[]],[[["scalar",6]],["signature",6]],[[["point",6],["signature",6]],["bool",15]],[[["error",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[]],[[],["scalar",6]],[[["scalar",6]],["point",6]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],[[["mode",4],["usize",15]],["vec",3,[["u8",15]]]],[[["mode",4]],["vec",3,[["u8",15]]]],[[["mode",4],["usize",15]],["vec",3,[["u8",15]]]],null,null,null,null,null,[[]],[[]],[[],["mode",4]],[[]],[[],["result",4]],[[["mode",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[["mode",4]],["usize",15]],[[["mode",4],["option",4,[["usize",15]]]],["vec",3,[["u8",15]]]],[[]],[[],["result",4]],[[["mode",4]],["usize",15]],[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]],null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],["signature",3]],[[]],[[],["result",4,[["error",4]]]],[[],["result",4,[["error",4]]]],[[["mode",4],["scalar",6],["nonce",6]],["result",4,[["signature",3],["error",4]]]],[[["mode",4],["signature",3]],["result",4,[["bool",15],["error",4]]]],[[["error",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[],["result",4,[["scalar",6],["error",4]]]],[[["scalar",6],["scalar",6]]],[[],["result",4,[["nonce",6],["error",4]]]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["result",4,[["publickey",6],["error",4]]]],[[],["result",4,[["scalar",6],["error",4]]]],[[]],[[]],[[],["",26,[["default",8],["fill",8]]]],[[["usize",15]],["vec",3,[["u8",15]]]],[[]],[[["usize",15]],["vec",3,[["u8",15]]]],null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[],["mode",4]],[[]],[[],["result",4]],[[["error",4]],["bool",15]],[[["mode",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["mode",4]],["result",4,[["error",4]]]],[[],["result",4]],[[["mode",4]],["result",4,[["vec",3,[["u8",15]]],["error",4]]]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[["mode",4]],["result",4,[["bool",15],["error",4]]]],[[]],[[]],null,null,null,null,[[]],[[]],[[["point",6],["scalar",6]],["result",4,[["point",6],["error",4]]]],[[["scalar",6]],["point",6]],[[["error",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[]],[[],["scalar",6]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[]]],"p":[[4,"Mode"],[4,"Error"],[3,"Aead"],[4,"Mode"],[4,"Error"],[3,"Digest"],[4,"Error"],[4,"Mode"],[4,"Error"],[4,"Mode"],[4,"Error"],[3,"Signature"],[4,"Mode"],[4,"Error"],[4,"Error"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};